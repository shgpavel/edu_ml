## build
```
  cmake -S . -B build
  cmake --build build
```

## run
```
  python main.py
```

## build dependencies
```
  cc
  libc (glibc recommended)
  cmake                     >= 3.20
  python-dev (dev headers)  >= 3.11
```

## q&a
  q: Насколько эффективно кодирование Хаффмана по сравнению с Gzip в каждом случае и чем
  объясняется разница в ту или иную сторону конкретно на этих тестах?
  
  a: Довольно эффективно, особенно в тех случаях, когда для хаффмана максимально тепличные
  условия (например тест 6). Отрыв у gzip получился только в тесте 5 поскольку там его
  deflate кодирует полностью слова и это получается выгоднее. Хотя также стоит сказать
  что я не стал добавлять в итоговый размер для хаффмана размер таблички, по идее
  нам чтобы более объективно сравнить необходимо добавить к huffman 
  ```sizeof(struct bitbuf) * ct_size ```
  
  q: В каких случаях кодирование не имело большого смысла?
  
  a: Ну в общем-то во всех имело, но наихудший результат показала обработка рандомного
  потока символов
  
  q: О чём говорит КПД Хаффмана?
  
  a: О близости нашего кода к максимально оптимальному теоритически возможному коду
  
  q: Какие закономерности можно заметить в коэффициентах сжатия? 
  (Почему низкие/высокие на конкретных тестах)
  
  a: На небольших тестах с большим числом повторов символов результат будет лучше,
  в потоках где встречаются одинаковые слова, предложения, куски лучше применять дополнительные
  алгоритмы по типу LZ77
